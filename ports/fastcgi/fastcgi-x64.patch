diff --git a/acinclude.m4 b/acinclude.m4
index c1648bda..e351d934 100644
--- a/acinclude.m4
+++ b/acinclude.m4
@@ -27,14 +27,12 @@ AC_DEFUN([FCGI_COMMON_CHECKS], [
 		   [Define if there's a fileno() prototype in stdio.h])],
 	    AC_MSG_RESULT([no]))
 
-    if test "$HAVE_SYS_SOCKET_H"; then
 	AC_MSG_CHECKING([for socklen_t in sys/socket.h])
 	AC_EGREP_HEADER([socklen_t], [sys/socket.h],
 	    [AC_MSG_RESULT([yes])
 	     AC_DEFINE([HAVE_SOCKLEN], [1],
 			       [Define if the socklen_t typedef is in sys/socket.h])],
 	   AC_MSG_RESULT([no]))
-    fi
 
     #--------------------------------------------------------------------
     #  Do we need cross-process locking on this platform?
-
-

diff --git a/libfcgi/os_win32.c b/libfcgi/os_win32.c
index 1a77ca6d..80ee3a76 100644
--- a/libfcgi/os_win32.c
+++ b/libfcgi/os_win32.c
@@ -16,6 +16,9 @@
  * (Special thanks to Karen and Bill.  They made my job much easier and
  *  significantly more enjoyable.)
  */
+#ifdef _WIN32
+#define DLLAPI  __declspec(dllexport)
+#endif
 
 #define WIN32_LEAN_AND_MEAN 
 #include <windows.h>
@@ -123,6 +126,15 @@ static FILE_TYPE listenType = FD_UNUSED;
 static HANDLE hListen = INVALID_HANDLE_VALUE;
 
 static BOOLEAN libInitialized = FALSE;
+HANDLE strToHandle(char *str)
+{
+#ifdef _WIN64
+    return (HANDLE)_atoi64(str);
+#else
+    return (HANDLE)atoi(str);
+#endif
+}
+
 
 /*
  *--------------------------------------------------------------
@@ -222,7 +234,7 @@ static int Win32NewDescriptor(FILE_TYPE type, int fd, int desiredFd)
 static void StdinThread(void * startup) 
 {
     int doIo = TRUE;
-    unsigned long fd;
+    ULONG_PTR fd;
     unsigned long bytesRead;
     POVERLAPPED_REQUEST pOv;
 
@@ -352,7 +364,7 @@ int OS_LibInit(int stdioFds[3])
     val = getenv(SHUTDOWN_EVENT_NAME);
     if (val != NULL) 
     {
-        HANDLE shutdownEvent = (HANDLE) atoi(val);
+        HANDLE shutdownEvent = strToHandle(val);
 
         if (_beginthread(ShutdownRequestThread, 0, shutdownEvent) == -1)
         {
@@ -366,7 +378,7 @@ int OS_LibInit(int stdioFds[3])
         val = getenv(MUTEX_VARNAME);
         if (val != NULL) 
         {
-            acceptMutex = (HANDLE) atoi(val);
+            acceptMutex = strToHandle(val);
         }
     }
 
@@ -455,8 +467,10 @@ int OS_LibInit(int stdioFds[3])
  */
     }
 
+	ASSERT(INT_MIN <= (intptr_t)stdioHandles[STDIN_FILENO] &&
+		(intptr_t)stdioHandles[STDIN_FILENO] <= INT_MAX);
     if ((fakeFd = Win32NewDescriptor(FD_PIPE_SYNC,
-				     (int)stdioHandles[STDIN_FILENO],
+				     (int)(intptr_t)stdioHandles[STDIN_FILENO],
 				     STDIN_FILENO)) == -1) {
         return -1;
     } else {
@@ -489,7 +503,7 @@ int OS_LibInit(int stdioFds[3])
     if((cLenPtr = getenv("CONTENT_LENGTH")) != NULL &&
        atoi(cLenPtr) > 0) {
         hStdinThread = (HANDLE) _beginthread(StdinThread, 0, NULL);
-	if (hStdinThread == (HANDLE) -1) {
+	if (hStdinThread == (HANDLE)(LONG_PTR) -1) {
 	    printf("<H2>OS_LibInit Failed to create STDIN thread!  ERROR: %lu</H2>\r\n\r\n",
 		   GetLastError());
 	    return -1;
@@ -510,8 +524,10 @@ int OS_LibInit(int stdioFds[3])
 	exit(99);
     }
 
+	ASSERT(INT_MIN <= (intptr_t)stdioHandles[STDOUT_FILENO] &&
+           (intptr_t)stdioHandles[STDOUT_FILENO] <= INT_MAX);
     if ((fakeFd = Win32NewDescriptor(FD_PIPE_SYNC,
-				     (int)stdioHandles[STDOUT_FILENO],
+				     (int)(intptr_t)stdioHandles[STDOUT_FILENO],
 				     STDOUT_FILENO)) == -1) {
         return -1;
     } else {
@@ -527,8 +543,10 @@ int OS_LibInit(int stdioFds[3])
         DebugBreak();
 	exit(99);
     }
+	ASSERT(INT_MIN <= (intptr_t)stdioHandles[STDERR_FILENO] &&
+           (intptr_t)stdioHandles[STDERR_FILENO] <= INT_MAX);
     if ((fakeFd = Win32NewDescriptor(FD_PIPE_SYNC,
-				     (int)stdioHandles[STDERR_FILENO],
+				     (int)(intptr_t)stdioHandles[STDERR_FILENO],
 				     STDERR_FILENO)) == -1) {
         return -1;
     } else {
@@ -730,7 +748,9 @@ int OS_CreateLocalIpcFd(const char *bindPath, int backlog)
 	        return -5;
 	    }
 
-        pseudoFd = Win32NewDescriptor(listenType, listenSock, -1);
+        ASSERT(INT_MIN <= (intptr_t)listenSock &&
+               (intptr_t)listenSock <= INT_MAX);
+        pseudoFd = Win32NewDescriptor(listenType, (int)(intptr_t)listenSock, -1);
         
         if (pseudoFd == -1) 
         {
@@ -771,7 +791,9 @@ int OS_CreateLocalIpcFd(const char *bindPath, int backlog)
             return -9;
         }
 
-        pseudoFd = Win32NewDescriptor(listenType, (int) hListenPipe, -1);
+        ASSERT(INT_MIN <= (intptr_t)hListenPipe &&
+               (intptr_t)hListenPipe <= INT_MAX);
+        pseudoFd = Win32NewDescriptor(listenType, (int)(intptr_t)hListenPipe, -1);
         
         if (pseudoFd == -1) 
         {
@@ -817,7 +839,7 @@ int OS_FcgiConnect(char *bindPath)
         if (*bindPath != ':')
         {
             char * p = strchr(bindPath, ':');
-            int len = p - bindPath;
+            intptr_t len = p - bindPath;
             host = malloc(len + 1);
             memcpy(host, bindPath, len);
             host[len] = '\0';
@@ -853,7 +875,8 @@ int OS_FcgiConnect(char *bindPath)
 	        return -1;
 	    }
 
-	    pseudoFd = Win32NewDescriptor(FD_SOCKET_SYNC, sock, -1);
+	    ASSERT(INT_MIN <= (intptr_t)sock && (intptr_t)sock <= INT_MAX);
+        pseudoFd = Win32NewDescriptor(FD_SOCKET_SYNC, (int)(intptr_t)sock, -1);
 	    if (pseudoFd == -1) 
         {
 	        closesocket(sock);
@@ -888,7 +911,8 @@ int OS_FcgiConnect(char *bindPath)
             return -1;
         }
 
-        pseudoFd = Win32NewDescriptor(FD_PIPE_ASYNC, (int) hPipe, -1);
+        ASSERT(INT_MIN <= (intptr_t)hPipe && (intptr_t)hPipe <= INT_MAX);
+        pseudoFd = Win32NewDescriptor(FD_PIPE_ASYNC, (int)(intptr_t)hPipe, -1);
         
         if (pseudoFd == -1) 
         {
@@ -943,7 +967,8 @@ int OS_Read(int fd, char * buf, size_t len)
 	case FD_PIPE_SYNC:
 	case FD_PIPE_ASYNC:
 
-	    if (ReadFile(fdTable[fd].fid.fileHandle, buf, len, &bytesRead, NULL)) 
+	    ASSERT(0 <= len && len <= ULONG_MAX);
+        if (ReadFile(fdTable[fd].fid.fileHandle, buf, (DWORD)len, &bytesRead, NULL))
         {
             ret = bytesRead;
         }
@@ -957,7 +982,8 @@ int OS_Read(int fd, char * buf, size_t len)
 	case FD_SOCKET_SYNC:
 	case FD_SOCKET_ASYNC:
 
-        ret = recv(fdTable[fd].fid.sock, buf, len, 0);
+        ASSERT(0 <= len && len <= INT_MAX);
+        ret = recv(fdTable[fd].fid.sock, buf, (int)len, 0);
 	    if (ret == SOCKET_ERROR) 
         {
 		    fdTable[fd].Errno = WSAGetLastError();
@@ -1006,7 +1032,8 @@ int OS_Write(int fd, char * buf, size_t len)
 	case FD_PIPE_SYNC:
 	case FD_PIPE_ASYNC:
 
-        if (WriteFile(fdTable[fd].fid.fileHandle, buf, len, &bytesWritten, NULL)) 
+        ASSERT(0 <= len && len <= ULONG_MAX);
+        if (WriteFile(fdTable[fd].fid.fileHandle, buf, (DWORD)len, &bytesWritten, NULL))
         {
             ret = bytesWritten;
         }
@@ -1020,7 +1047,8 @@ int OS_Write(int fd, char * buf, size_t len)
 	case FD_SOCKET_SYNC:
 	case FD_SOCKET_ASYNC:
 
-        ret = send(fdTable[fd].fid.sock, buf, len, 0);
+        ASSERT(0 <= len && len <= INT_MAX);
+        ret = send(fdTable[fd].fid.sock, buf, (int)len, 0);
         if (ret == SOCKET_ERROR) 
         {
 		    fdTable[fd].Errno = WSAGetLastError();
@@ -1387,7 +1415,7 @@ int OS_Close(int fd, int shutdown_ok)
             {
                 struct timeval tv;
                 fd_set rfds;
-                int sock = fdTable[fd].fid.sock;
+                SOCKET sock = fdTable[fd].fid.sock;
                 int rv;
                 char trash[1024];
    
@@ -1395,11 +1423,11 @@ int OS_Close(int fd, int shutdown_ok)
 
                 do 
                 {
-	            FD_SET((unsigned) sock, &rfds);
+	            FD_SET(sock, &rfds);
                     
 	            tv.tv_sec = 2;
 	            tv.tv_usec = 0;
-	            rv = select(sock + 1, &rfds, NULL, NULL, &tv);
+	            rv = select(0, &rfds, NULL, NULL, &tv);
                 }
                 while (rv > 0 && recv(sock, trash, sizeof(trash), 0) > 0);
             }
@@ -1467,12 +1495,12 @@ int OS_CloseRead(int fd)
  */
 int OS_DoIo(struct timeval *tmo)
 {
-    unsigned long fd;
+    ULONG_PTR fd;
     unsigned long bytes;
     POVERLAPPED_REQUEST pOv;
     struct timeb tb;
-    int ms;
-    int ms_last;
+    time_t ms;
+    time_t ms_last;
     int err;
 
     /* XXX
@@ -1490,8 +1518,9 @@ int OS_DoIo(struct timeval *tmo)
     while (ms >= 0) {
 	if(tmo && (ms = tmo->tv_sec*1000 + tmo->tv_usec/1000)> 100)
 	    ms = 100;
+	ASSERT(0 <= ms && ms < 0xFFFFFFFF);
 	if (!GetQueuedCompletionStatus(hIoCompPort, &bytes, &fd,
-	    (LPOVERLAPPED *)&pOv, ms) && !pOv) {
+	    (LPOVERLAPPED *)&pOv, (DWORD)ms) && !pOv) {
 	    err = WSAGetLastError();
 	    return 0; /* timeout */
         }
@@ -1546,7 +1575,7 @@ static int CALLBACK isAddrOKCallback(LPWSABUF  lpCallerId,
                                      LPWSABUF  dc3,
                                      LPWSABUF  dc4,
                                      GROUP     *dc5,
-                                     DWORD     data)
+                                     DWORD_PTR     data)
 {
     struct sockaddr_in *sockaddr = (struct sockaddr_in *) lpCallerId->buf;
 
@@ -1617,7 +1646,8 @@ static int acceptNamedPipe()
         }
     }
 
-    ipcFd = Win32NewDescriptor(FD_PIPE_SYNC, (int) hListen, -1);
+    ASSERT(INT_MIN <= (intptr_t)hListen && (intptr_t)hListen <= INT_MAX);
+    ipcFd = Win32NewDescriptor(FD_PIPE_SYNC, (int)(intptr_t)hListen, -1);
 	if (ipcFd == -1) 
     {
         DisconnectNamedPipe(hListen);
@@ -1643,7 +1673,7 @@ static int acceptSocket(const char *webServerAddrs)
 
             FD_ZERO(&readfds);
 
-            FD_SET((unsigned int) hListen, &readfds);
+            FD_SET((SOCKET)hListen, &readfds);
 
             if (select(0, &readfds, NULL, NULL, &timeout) == 0)
             {
@@ -1674,11 +1704,11 @@ static int acceptSocket(const char *webServerAddrs)
 
         closesocket(hSock);
 #else
-        hSock = WSAAccept((unsigned int) hListen,                    
+        hSock = WSAAccept((SOCKET)hListen,                 
                           &sockaddr,  
                           &sockaddrLen,               
                           isAddrOKCallback,  
-                          (DWORD) webServerAddrs);
+                          (DWORD_PTR) webServerAddrs);
 
         if (hSock != INVALID_SOCKET)
         {
@@ -1699,7 +1729,8 @@ static int acceptSocket(const char *webServerAddrs)
         return -1;
     }
     
-    ipcFd = Win32NewDescriptor(FD_SOCKET_SYNC, hSock, -1);
+    ASSERT(INT_MIN <= (intptr_t)hSock && (intptr_t)hSock <= INT_MAX);
+    ipcFd = Win32NewDescriptor(FD_SOCKET_SYNC, (int)(intptr_t)hSock, -1);
 	if (ipcFd == -1) 
     {
 	    closesocket(hSock);
-
-

diff --git a/libfcgi/fcgio.cpp b/libfcgi/fcgio.cpp
index f42b6cf6..6c9237d6 100644
--- a/libfcgi/fcgio.cpp
+++ b/libfcgi/fcgio.cpp
@@ -17,10 +17,15 @@
 // This code is offered as-is without any warranty either expressed or
 // implied; without even the implied warranty of MERCHANTABILITY or
 // FITNESS FOR A PARTICULAR PURPOSE.
+#ifdef _WIN32
+#define DLLAPI  __declspec(dllexport)
+#endif
 
+#include <assert.h>
 #include <stdio.h>
 #include <limits.h>
 #include "fcgio.h"
+#include "fcgimisc.h"
 
 using std::streambuf;
 using std::istream;
@@ -60,12 +65,13 @@ int fcgi_streambuf::overflow(int c)
 {
     if (this->bufsize)
     {
-        int plen = pptr() - pbase();
+        intptr_t plen = pptr() - pbase();
 
         if (plen) 
         {
-            if (FCGX_PutStr(pbase(), plen, this->fcgx) != plen) return EOF;
-            pbump(-plen);
+            ASSERT(0 <= plen && plen <= INT_MAX);
+            if (FCGX_PutStr(pbase(), (int)plen, this->fcgx) != plen) return EOF;
+            pbump((int)(-plen));
         }
     }
 
@@ -106,7 +112,8 @@ int fcgi_streambuf::underflow()
     {
         if (in_avail() == 0)
         {
-            int glen = FCGX_GetStr(eback(), this->bufsize, this->fcgx);
+            ASSERT(0 <= this->bufsize && this->bufsize <= INT_MAX);
+            int glen = FCGX_GetStr(eback(), (int)(this->bufsize), this->fcgx);
             if (glen <= 0) return EOF;
 
             setg(eback(), eback(), eback() + glen);
-
-

diff --git a/libfcgi/fcgiapp.c b/libfcgi/fcgiapp.c
index e8a500bd..954c8cf1 100644
--- a/libfcgi/fcgiapp.c
+++ b/libfcgi/fcgiapp.c
@@ -10,6 +10,9 @@
  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
  *
  */
+#ifdef _WIN32
+#define DLLAPI  __declspec(dllexport)
+#endif
 
 #include <assert.h>
 #include <errno.h>
@@ -22,6 +25,11 @@
 #include <string.h>
 #include <sys/types.h>
 
+#ifndef _WIN32
+#include <stdint.h>
+#include <limits.h>
+#endif
+
 #include "fcgi_config.h"
 
 #ifdef HAVE_SYS_SOCKET_H
@@ -56,6 +64,12 @@
 #define LONG_DOUBLE long double
 #endif
 
+#ifdef _WIN64
+#define ABS(a) _abs64(a)
+#else
+#define ABS(a) abs(a)
+#endif
+
 /*
  * Globals
  */
@@ -78,7 +92,7 @@ static void *Malloc(size_t size)
 
 static char *StringCopy(char *str)
 {
-    int strLen = strlen(str);
+    size_t strLen = strlen(str);
     char *newString = (char *)Malloc(strLen + 1);
     memcpy(newString, str, strLen);
     newString[strLen] = '\000';
@@ -135,7 +149,7 @@ int FCGX_GetChar(FCGX_Stream *stream)
  */
 int FCGX_GetStr(char *str, int n, FCGX_Stream *stream)
 {
-    int m, bytesMoved;
+    intptr_t m, bytesMoved;
 
     if (stream->isClosed || ! stream->isReader || n <= 0) {
         return 0;
@@ -159,15 +173,21 @@ int FCGX_GetStr(char *str, int n, FCGX_Stream *stream)
             memcpy(str, stream->rdNext, m);
             bytesMoved += m;
             stream->rdNext += m;
-            if(bytesMoved == n)
-                return bytesMoved;
+            if(bytesMoved == n) {
+                ASSERT(INT_MIN <= bytesMoved && bytesMoved <= INT_MAX);
+                return (int)bytesMoved;
+            }
             str += m;
         }
-        if(stream->isClosed || !stream->isReader)
-            return bytesMoved;
+        if(stream->isClosed || !stream->isReader) {
+            ASSERT(INT_MIN <= bytesMoved && bytesMoved <= INT_MAX);
+            return (int)bytesMoved;
+        }
         stream->fillBuffProc(stream);
-        if (stream->isClosed)
-            return bytesMoved;
+        if (stream->isClosed) {
+            ASSERT(INT_MIN <= bytesMoved && bytesMoved <= INT_MAX);
+            return (int)bytesMoved;
+        }
 
         stream->stopUnget = stream->rdNext;
     }
@@ -302,7 +322,7 @@ int FCGX_PutChar(int c, FCGX_Stream *stream)
  */
 int FCGX_PutStr(const char *str, int n, FCGX_Stream *stream)
 {
-    int m, bytesMoved;
+    intptr_t m, bytesMoved;
 
     /*
      * Fast path: room for n bytes in the buffer
@@ -323,8 +343,10 @@ int FCGX_PutStr(const char *str, int n, FCGX_Stream *stream)
             memcpy(stream->wrNext, str, m);
             bytesMoved += m;
             stream->wrNext += m;
-            if(bytesMoved == n)
-                return bytesMoved;
+            if(bytesMoved == n) {
+                ASSERT(INT_MIN <= bytesMoved && bytesMoved <= INT_MAX);
+                return (int)bytesMoved;
+            }
             str += m;
 	}
         if(stream->isClosed || stream->isReader)
@@ -348,7 +370,9 @@ int FCGX_PutStr(const char *str, int n, FCGX_Stream *stream)
  */
 int FCGX_PutS(const char *str, FCGX_Stream *stream)
 {
-    return FCGX_PutStr(str, strlen(str), stream);
+    size_t sz = strlen(str);
+    ASSERT(sz <= INT_MAX);
+    return FCGX_PutStr(str, (int)sz, stream);
 }
 
 /*
@@ -399,15 +423,17 @@ int FCGX_FPrintF(FCGX_Stream *stream, const char *format, ...)
     /*
      * Max size of a format specifier is 1 + 5 + 7 + 7 + 2 + 1 + slop
      */
-static void CopyAndAdvance(char **destPtr, char **srcPtr, int n);
+static void CopyAndAdvance(char **destPtr, char **srcPtr, intptr_t n);
 
 int FCGX_VFPrintF(FCGX_Stream *stream, const char *format, va_list arg)
 {
     char *f, *fStop, *percentPtr, *p, *fmtBuffPtr, *buffPtr;
-    int op, performedOp, sizeModifier, buffCount = 0, buffLen, specifierLength;
-    int fastPath, n, auxBuffLen = 0, buffReqd, minWidth, precision, exp;
+    intptr_t op, performedOp, sizeModifier, buffCount = 0, buffLen;
+    intptr_t fastPath, n, auxBuffLen = 0, minWidth, precision;
+    int exp;
+    intptr_t specifierLength, buffReqd;
     char *auxBuffPtr = NULL;
-    int streamCount = 0;
+    intptr_t streamCount = 0;
     char fmtBuff[FMT_BUFFLEN];
     char buff[PRINTF_BUFFLEN];
 
@@ -434,10 +460,11 @@ int FCGX_VFPrintF(FCGX_Stream *stream, const char *format, va_list arg)
         percentPtr = (char *)memchr(f, '%', fStop - f);
         if(percentPtr == NULL) percentPtr = fStop;
         if(percentPtr != f) {
-            if(FCGX_PutStr(f, percentPtr - f, stream) < 0)
+            intptr_t ptrDiff = percentPtr - f;
+            ASSERT(0 <= ptrDiff && ptrDiff < INT_MAX);
+            if(FCGX_PutStr(f, (int)ptrDiff, stream) < 0)
                 goto ErrorReturn;
-            streamCount += percentPtr - f;
-            f = percentPtr;
+            streamCount += (int)ptrDiff;
             if(f == fStop) break;
 	}
         fastPath = TRUE;
@@ -511,14 +538,14 @@ int FCGX_VFPrintF(FCGX_Stream *stream, const char *format, va_list arg)
                 if(n == 0) {
                     if(*p == '*') {
                         minWidth = va_arg(arg, int);
-                        if(abs(minWidth) > 999999)
+                        if(ABS(minWidth) > 999999)
                             goto ErrorReturn;
 			/*
 			 * The following use of strlen rather than the
 			 * value returned from sprintf is because SUNOS4
 			 * returns a char * instead of an int count.
 			 */
-			sprintf(fmtBuffPtr, "%d", minWidth);
+			sprintf(fmtBuffPtr, "%lld", (long long)minWidth);
                         fmtBuffPtr += strlen(fmtBuffPtr);
                         p++;
 	            } else {
@@ -547,7 +574,7 @@ int FCGX_VFPrintF(FCGX_Stream *stream, const char *format, va_list arg)
 			 * value returned from sprintf is because SUNOS4
 			 * returns a char * instead of an int count.
 			 */
-			    sprintf(fmtBuffPtr, "%d", precision);
+			    sprintf(fmtBuffPtr, "%lld", (long long)precision);
 			    fmtBuffPtr += strlen(fmtBuffPtr);
                             p++;
 	                } else {
@@ -784,11 +811,13 @@ int FCGX_VFPrintF(FCGX_Stream *stream, const char *format, va_list arg)
                     switch(sizeModifier) {
                         case ' ':
                             intPtrArg = va_arg(arg, int *);
-                            *intPtrArg = streamCount;
+                            ASSERT(INT_MIN <= streamCount && streamCount <= INT_MAX);
+							*intPtrArg = (int)streamCount;
                             break;
                         case 'l':
                             longPtrArg = va_arg(arg, long *);
-                            *longPtrArg = streamCount;
+                            ASSERT(LONG_MIN <= streamCount && streamCount <= LONG_MAX);
+							*longPtrArg = (long)streamCount;
                             break;
                         case 'h':
                             shortPtrArg = (short *) va_arg(arg, short *);
@@ -855,7 +884,8 @@ int FCGX_VFPrintF(FCGX_Stream *stream, const char *format, va_list arg)
         } /* for (;;) */
         ASSERT(buffCount < buffLen);
         if(buffCount > 0) {
-            if(FCGX_PutStr(buffPtr, buffCount, stream) < 0)
+            ASSERT(0 <= buffCount && buffCount <= INT_MAX);
+			if(FCGX_PutStr(buffPtr, (int)buffCount, stream) < 0)
                 goto ErrorReturn;
             streamCount += buffCount;
         } else if(buffCount < 0) {
@@ -868,18 +898,19 @@ int FCGX_VFPrintF(FCGX_Stream *stream, const char *format, va_list arg)
     streamCount = -1;
   NormalReturn:
     if(auxBuffPtr != NULL) free(auxBuffPtr);
-    return streamCount;
+    ASSERT(INT_MIN <= streamCount && streamCount <= INT_MAX);
+	return (int)streamCount;
 }
 
 /*
  * Copy n characters from *srcPtr to *destPtr, then increment
  * both *srcPtr and *destPtr by n.
  */
-static void CopyAndAdvance(char **destPtr, char **srcPtr, int n)
+static void CopyAndAdvance(char **destPtr, char **srcPtr, intptr_t n)
 {
     char *dest = *destPtr;
     char *src = *srcPtr;
-    int i;
+    intptr_t i;
     for (i = 0; i < n; i++)
         *dest++ = *src++;
     *destPtr = dest;
@@ -1095,7 +1126,7 @@ static void FreeParams(ParamsPtr *paramsPtrPtr)
  */
 static void PutParam(ParamsPtr paramsPtr, char *nameValue)
 {
-    int size;
+    intptr_t size;
 
     *paramsPtr->cur++ = nameValue;
     size = paramsPtr->cur - paramsPtr->vec;
@@ -1122,7 +1153,7 @@ static void PutParam(ParamsPtr paramsPtr, char *nameValue)
  */
 char *FCGX_GetParam(const char *name, FCGX_ParamArray envp)
 {
-    int len;
+    intptr_t len;
     char **p;
 
 	if (name == NULL || envp == NULL) return NULL;
@@ -1289,8 +1320,8 @@ static FCGI_UnknownTypeBody MakeUnknownTypeBody(
  *
  *----------------------------------------------------------------------
  */
-static int AlignInt8(unsigned n) {
-    return (n + 7) & (UINT_MAX - 7);
+static intptr_t AlignInt8(intptr_t n) {
+    return (n + 7) & ~7;
 }
 
 /*
@@ -1304,9 +1335,7 @@ static int AlignInt8(unsigned n) {
  *----------------------------------------------------------------------
  */
 static unsigned char *AlignPtr8(unsigned char *p) {
-    unsigned long u = (unsigned long) p;
-    u = ((u + 7) & (ULONG_MAX - 7)) - u;
-    return p + u;
+    return (unsigned char *)((((uintptr_t)p) + 7) & ~7);
 }
 
 
@@ -1379,9 +1408,9 @@ static void WriteCloseRecords(struct FCGX_Stream *stream)
 
 
 
-static int write_it_all(int fd, char *buf, int len)
+static intptr_t write_it_all(int fd, char *buf, intptr_t len)
 {
-    int wrote;
+    intptr_t wrote;
 
     while (len) {
         wrote = OS_Write(fd, buf, len);
@@ -1406,7 +1435,7 @@ static int write_it_all(int fd, char *buf, int len)
 static void EmptyBuffProc(struct FCGX_Stream *stream, int doClose)
 {
     FCGX_Stream_Data *data = (FCGX_Stream_Data *)stream->data;
-    int cLen, eLen;
+    intptr_t cLen, eLen;
     /*
      * If the buffer contains stream data, fill in the header.
      * Pad the record to a multiple of 8 bytes in length.  Padding
@@ -1423,9 +1452,11 @@ static void EmptyBuffProc(struct FCGX_Stream *stream, int doClose)
              */
             memset(stream->wrNext, 0, eLen - cLen);
             stream->wrNext += eLen - cLen;
+			ASSERT(0 <= cLen && cLen <= INT_MAX);
+            ASSERT(0 <= eLen - cLen && eLen - cLen <= INT_MAX);
             *((FCGI_Header *) data->buff)
                     = MakeHeader(data->type,
-                            data->reqDataPtr->requestId, cLen, eLen - cLen);
+                            data->reqDataPtr->requestId, (int)cLen, (int)(eLen - cLen));
         } else {
             stream->wrNext = data->buff;
 	}
@@ -1479,7 +1510,7 @@ static int ProcessManagementRecord(int type, FCGX_Stream *stream)
     char response[64]; /* 64 = 8 + 3*(1+1+14+1)* + padding */
     char *responseP = &response[FCGI_HEADER_LEN];
     char *name, value = '\0';
-    int len, paddedLen;
+    intptr_t len, paddedLen;
     if(type == FCGI_GET_VALUES) {
         ReadParams(paramsPtr, stream);
         if((FCGX_GetError(stream) != 0) || (data->contentLen != 0)) {
@@ -1503,22 +1534,25 @@ static int ProcessManagementRecord(int type, FCGX_Stream *stream)
             }
             if(name != NULL) {
                 len = strlen(name);
-                sprintf(responseP, "%c%c%s%c", len, 1, name, value);
+                sprintf(responseP, "%c%c%s%c", (int)len, 1, name, value);
                 responseP += len + 3;
 	    }
         }
         len = responseP - &response[FCGI_HEADER_LEN];
         paddedLen = AlignInt8(len);
         FCGI_Header *header = (FCGI_Header *)response;
+		ASSERT(0 <= len && len <= INT_MAX);
+        ASSERT(0 <= paddedLen - len && paddedLen - len <= INT_MAX);
         *header = MakeHeader(FCGI_GET_VALUES_RESULT, FCGI_NULL_REQUEST_ID,
-                             len, paddedLen - len);
+                             (int)len, (int)(paddedLen - len));
         FreeParams(&paramsPtr);
     } else {
         paddedLen = len = sizeof(FCGI_UnknownTypeBody);
+		ASSERT(0 <= len && len <= INT_MAX);
         FCGI_UnknownTypeRecord *utr = (FCGI_UnknownTypeRecord *) response;
         utr->header
             = MakeHeader(FCGI_UNKNOWN_TYPE, FCGI_NULL_REQUEST_ID,
-                         len, 0);
+                         (int)len, 0);
         utr->body
             = MakeUnknownTypeBody(type);
     }
@@ -1650,7 +1684,8 @@ static void FillBuffProc(FCGX_Stream *stream)
     FCGX_Stream_Data *data = (FCGX_Stream_Data *)stream->data;
     FCGI_Header header;
     int headerLen = 0;
-    int status, count;
+    intptr_t status, count;
+	intptr_t ptrDiff;
 
     for (;;) {
         /*
@@ -1671,7 +1706,9 @@ static void FillBuffProc(FCGX_Stream *stream)
          * more content bytes, deliver all that are present in data->buff.
          */
         if(data->contentLen > 0) {
-            count = min(data->contentLen, data->buffStop - stream->rdNext);
+            ptrDiff = data->buffStop - stream->rdNext;
+            ASSERT(0 <= ptrDiff && ptrDiff <= INT_MAX);
+            count = min(data->contentLen, (int)ptrDiff);
             data->contentLen -= count;
             if(!data->skip) {
                 stream->wrNext = stream->stop = stream->rdNext + count;
@@ -1690,7 +1727,9 @@ static void FillBuffProc(FCGX_Stream *stream)
          * the client) was padded, skip over the padding bytes.
          */
         if(data->paddingLen > 0) {
-            count = min(data->paddingLen, data->buffStop - stream->rdNext);
+			ptrDiff = data->buffStop - stream->rdNext;
+            ASSERT(0 <= ptrDiff && ptrDiff <= INT_MAX);
+            count = min(data->paddingLen, (int)ptrDiff);
             data->paddingLen -= count;
             stream->rdNext += count;
             if(data->paddingLen > 0) {
@@ -1709,8 +1748,10 @@ static void FillBuffProc(FCGX_Stream *stream)
         /*
          * Fill header with bytes from the input buffer.
          */
+		ptrDiff = data->buffStop - stream->rdNext;
+        ASSERT(0 <= ptrDiff && ptrDiff <= INT_MAX);
         count = min((int)sizeof(header) - headerLen,
-                        data->buffStop - stream->rdNext);
+                        (int)ptrDiff);
         memcpy(((char *)(&header)) + headerLen, stream->rdNext, count);
         headerLen += count;
         stream->rdNext += count;
@@ -1778,6 +1819,7 @@ static void FillBuffProc(FCGX_Stream *stream)
 static FCGX_Stream *NewStream(
         FCGX_Request *reqDataPtr, int bufflen, int isReader, int streamType)
 {
+	intptr_t bufflen_p;
     /*
      * XXX: It would be a lot cleaner to have a NewStream that only
      * knows about the type FCGX_Stream, with all other
@@ -1789,7 +1831,9 @@ static FCGX_Stream *NewStream(
     FCGX_Stream *stream = (FCGX_Stream *)Malloc(sizeof(FCGX_Stream));
     FCGX_Stream_Data *data = (FCGX_Stream_Data *)Malloc(sizeof(FCGX_Stream_Data));
     data->reqDataPtr = reqDataPtr;
-    bufflen = AlignInt8(min(max(bufflen, 32), FCGI_MAX_LENGTH + 1));
+    bufflen_p = AlignInt8(min(max(bufflen, 32), FCGI_MAX_LENGTH + 1));
+    ASSERT(0 <= bufflen_p && bufflen_p <= INT_MAX);
+    bufflen = (int)bufflen_p;
     data->bufflen = bufflen;
     data->mBuff = (unsigned char *)Malloc(bufflen);
     data->buff = AlignPtr8(data->mBuff);

-
-

diff --git a/libfcgi/fcgi_stdio.c b/libfcgi/fcgi_stdio.c
index 93cdefc3..97c7c9e5 100644
--- a/libfcgi/fcgi_stdio.c
+++ b/libfcgi/fcgi_stdio.c	
@@ -10,11 +10,16 @@
  * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
  *
  */
+#ifdef _WIN32
+#define DLLAPI  __declspec(dllexport)
+#endif
 
 #include <errno.h>  /* for errno */
 #include <stdarg.h> /* for va_arg */
 #include <stdlib.h> /* for malloc */
 #include <string.h> /* for strerror */
+#include <assert.h>
+#include <limits.h>
 
 #include "fcgi_config.h"
 
@@ -53,6 +58,8 @@ extern int pclose(FILE *stream);
 
 #define popen _popen
 #define pclose _pclose
+#define fdopen _fdopen
+#define fileno _fileno
 
 #endif /* _WIN32 */
 
@@ -659,8 +666,10 @@ size_t FCGI_fread(void *ptr, size_t size, size_t nmemb, FCGI_FILE *fp)
         if((size * nmemb) == 0) {
             return 0;
         }
-        n = FCGX_GetStr((char *) ptr, size * nmemb, fp->fcgx_stream);
-        return (n/size);
+        ASSERT(size * nmemb < (size_t)INT_MAX);
+        n = FCGX_GetStr((char *) ptr, (int)(size * nmemb), fp->fcgx_stream);
+        ASSERT(n >= 0);
+        return ((size_t)n/size);
     }
     return (size_t)EOF;
 }
@@ -674,8 +683,10 @@ size_t FCGI_fwrite(void *ptr, size_t size, size_t nmemb, FCGI_FILE *fp)
         if((size * nmemb) == 0) {
             return 0;
         }
-        n = FCGX_PutStr((char *) ptr, size * nmemb, fp->fcgx_stream);
-        return (n/size);
+        ASSERT(size * nmemb < (size_t)INT_MAX);
+        n = (size_t)FCGX_PutStr((char *) ptr, (int)(size * nmemb), fp->fcgx_stream);
+        ASSERT(n >= 0);
+        return ((size_t)n/size);
     }
     return (size_t)EOF;
 }
-
-

diff --git a/libfcgi/libfcgi.mak b/libfcgi/libfcgi.mak
index 1aab4108..db2e7e2d 100644
--- a/libfcgi/libfcgi.mak
+++ b/libfcgi/libfcgi.mak
@@ -41,7 +41,7 @@ CLEAN :
 	-@erase "$(INTDIR)\fcgiapp.obj"
 	-@erase "$(INTDIR)\fcgio.obj"
 	-@erase "$(INTDIR)\os_win32.obj"
-	-@erase "$(INTDIR)\vc60.idb"
+	-@erase "$(INTDIR)\vc140.idb"
 	-@erase "$(OUTDIR)\libfcgi.dll"
 	-@erase "$(OUTDIR)\libfcgi.exp"
 	-@erase "$(OUTDIR)\libfcgi.lib"
@@ -50,7 +50,7 @@ CLEAN :
     if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
 
 CPP=cl.exe
-CPP_PROJ=/nologo /MD /W3 /O2 /Ob2 /I "..\include" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Fp"$(INTDIR)\libfcgi.pch" /YX /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /c 
+CPP_PROJ=/nologo /MD /W3 /O2 /Ob2 /I "..\include" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Fp"$(INTDIR)\libfcgi.pch" /nologo /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /c 
 
 .c{$(INTDIR)}.obj::
    $(CPP) @<<
@@ -90,7 +90,7 @@ BSC32_FLAGS=/nologo /o"$(OUTDIR)\libfcgi.bsc"
 BSC32_SBRS= \
 	
 LINK32=link.exe
-LINK32_FLAGS=Ws2_32.lib /nologo /dll /pdb:none /machine:I386 /out:"$(OUTDIR)\libfcgi.dll" /implib:"$(OUTDIR)\libfcgi.lib" 
+LINK32_FLAGS=Ws2_32.lib /nologo /dll /pdb:none  /out:"$(OUTDIR)\libfcgi.dll" /implib:"$(OUTDIR)\libfcgi.lib" 
 LINK32_OBJS= \
 	"$(INTDIR)\fcgi_stdio.obj" \
 	"$(INTDIR)\fcgiapp.obj" \
@@ -122,8 +122,8 @@ CLEAN :
 	-@erase "$(INTDIR)\fcgio.sbr"
 	-@erase "$(INTDIR)\os_win32.obj"
 	-@erase "$(INTDIR)\os_win32.sbr"
-	-@erase "$(INTDIR)\vc60.idb"
-	-@erase "$(INTDIR)\vc60.pdb"
+	-@erase "$(INTDIR)\vc140.idb"
+	-@erase "$(INTDIR)\vc140.pdb"
 	-@erase "$(OUTDIR)\libfcgi.bsc"
 	-@erase "$(OUTDIR)\libfcgi.dll"
 	-@erase "$(OUTDIR)\libfcgi.exp"
@@ -134,7 +134,7 @@ CLEAN :
     if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
 
 CPP=cl.exe
-CPP_PROJ=/nologo /MDd /W4 /Gm /Gi /ZI /Od /I "..\include" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /FR"$(INTDIR)\\" /Fp"$(INTDIR)\libfcgi.pch" /YX /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /GZ /c 
+CPP_PROJ=/nologo /MDd /W4 /Gm /Gi /ZI /Od /I "..\include" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /FR"$(INTDIR)\\" /Fp"$(INTDIR)\libfcgi.pch" /nologo /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /GZ /c 
 
 .c{$(INTDIR)}.obj::
    $(CPP) @<<
@@ -183,7 +183,7 @@ BSC32_SBRS= \
 <<
 
 LINK32=link.exe
-LINK32_FLAGS=Ws2_32.lib /nologo /dll /profile /map:"$(INTDIR)\libfcgi.map" /debug /machine:I386 /out:"$(OUTDIR)\libfcgi.dll" /implib:"$(OUTDIR)\libfcgi.lib" 
+LINK32_FLAGS=Ws2_32.lib /nologo /dll /profile /map:"$(INTDIR)\libfcgi.map" /debug  /out:"$(OUTDIR)\libfcgi.dll" /implib:"$(OUTDIR)\libfcgi.lib" 
 LINK32_OBJS= \
 	"$(INTDIR)\fcgi_stdio.obj" \
 	"$(INTDIR)\fcgiapp.obj" \
@@ -266,7 +266,7 @@ SOURCE=..\libfcgi\fcgio.cpp
 
 !IF  "$(CFG)" == "release"
 
-CPP_SWITCHES=/nologo /MD /W3 /GX /O2 /Ob2 /I "..\include" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Fp"$(INTDIR)\libfcgi.pch" /YX /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /c 
+CPP_SWITCHES=/nologo /MD /W3 /EHsc /O2 /Ob2 /I "..\include" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Fp"$(INTDIR)\libfcgi.pch" /nologo /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /c 
 
 "$(INTDIR)\fcgio.obj" : $(SOURCE) "$(INTDIR)"
 	$(CPP) @<<
@@ -276,7 +276,7 @@ CPP_SWITCHES=/nologo /MD /W3 /GX /O2 /Ob2 /I "..\include" /D "WIN32" /D "NDEBUG"
 
 !ELSEIF  "$(CFG)" == "debug"
 
-CPP_SWITCHES=/nologo /MDd /W3 /Gm /Gi /GX /ZI /Od /I "..\include" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /FR"$(INTDIR)\\" /Fp"$(INTDIR)\libfcgi.pch" /YX /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /GZ /c 
+CPP_SWITCHES=/nologo /MDd /W3 /Gm /Gi /EHsc /ZI /Od /I "..\include" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /FR"$(INTDIR)\\" /Fp"$(INTDIR)\libfcgi.pch" /nologo /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /GZ /c 
 
 "$(INTDIR)\fcgio.obj"	"$(INTDIR)\fcgio.sbr" : $(SOURCE) "$(INTDIR)"
 	$(CPP) @<<
-
-

diff --git a/cgi-fcgi/cgi-fcgi.c b/cgi-fcgi/cgi-fcgi.c
index 53b92678..5cb0839c 100644
--- a/cgi-fcgi/cgi-fcgi.c
+++ b/cgi-fcgi/cgi-fcgi.c
@@ -59,7 +59,6 @@ static int fcgiWritePending = 0;
 
 static void ScheduleIo(void);
 
-
 /*
  * Simple buffer (not ring buffer) type, used by all event handlers.
  */
@@ -86,12 +85,14 @@ typedef struct {
 static int GetPtr(char **ptr, int n, Buffer *pBuf)
 {
     int result;
+	intptr_t ptrDiff;
     *ptr = pBuf->next;
-    result = min(n, pBuf->stop - pBuf->next);
+    ptrDiff = pBuf->stop - pBuf->next;
+    ASSERT(0 <= ptrDiff && ptrDiff <= INT_MAX);
+    result = min(n, (int)ptrDiff);
     pBuf->next += result;
     return result;
 }
-
 /*
  *----------------------------------------------------------------------
  *
@@ -120,7 +121,6 @@ static FCGI_Header MakeHeader(
     header.reserved         =  0;
     return header;
 }
-
 /*
  *----------------------------------------------------------------------
  *
@@ -143,7 +143,6 @@ static FCGI_BeginRequestBody MakeBeginRequestBody(
     return body;
 }
 
-
 static int bytesToRead;    /* number of bytes to read from Web Server */
 static int appServerSock = -1;  /* Socket connected to FastCGI application,
                                  * used by AppServerReadHandler and
@@ -174,7 +173,6 @@ static int exitStatusSet = FALSE;
 
 static int stdinFds[3];
 
-
 /*
  *----------------------------------------------------------------------
  *
@@ -198,7 +196,6 @@ static void FCGIexit(int exitCode)
 #undef exit
 #define exit FCGIexit
 
-
 /*
  *----------------------------------------------------------------------
  *
@@ -339,7 +336,6 @@ static void AppServerReadHandler(ClientData dc, int bytesRead)
     } /*while*/
     ScheduleIo();
 }
-
 static Buffer fromWS;   /* Buffer for data read from Web server
                          * and written to FastCGI application. Used
                          * by WebServerReadHandler and
@@ -397,7 +393,6 @@ static void WebServerReadHandler(ClientData dc, int bytesRead)
 
     ScheduleIo();
 }
-
 /*
  *----------------------------------------------------------------------
  *
@@ -412,7 +407,7 @@ static void WebServerReadHandler(ClientData dc, int bytesRead)
 
 static void AppServerWriteHandler(ClientData dc, int bytesWritten)
 {
-    int length = fromWS.stop - fromWS.next;
+    intptr_t length = fromWS.stop - fromWS.next;
 
     /* Touch unused parameters to avoid warnings */
     dc = NULL;
@@ -433,7 +428,6 @@ static void AppServerWriteHandler(ClientData dc, int bytesWritten)
     ScheduleIo();
 }
 
-
 /*
  * ScheduleIo --
  *
@@ -449,14 +443,16 @@ static void AppServerWriteHandler(ClientData dc, int bytesWritten)
  */
 static void ScheduleIo(void)
 {
-    int length;
+    intptr_t length;
 
     /*
      * Move data between standard in and the FastCGI connection.
      */
+	length = fromWS.stop - fromWS.next;
     if(!fcgiWritePending && appServerSock != -1 &&
-       ((length = fromWS.stop - fromWS.next) != 0)) {
-	if(OS_AsyncWrite(appServerSock, 0, fromWS.next, length,
+       (length != 0)) {
+        ASSERT(0 <= length && length <= INT_MAX);
+        if(OS_AsyncWrite(appServerSock, 0, fromWS.next, (int)length,
 			 AppServerWriteHandler,
 			 (ClientData)(intptr_t)appServerSock) == -1) {
 	    FCGIexit(OS_Errno);
@@ -497,7 +493,6 @@ static void ScheduleIo(void)
     }
 }
 
-
 /*
  *----------------------------------------------------------------------
  *
@@ -533,7 +528,6 @@ static void FCGI_Start(char *bindPath, char *appPath, int nServers)
     }
     OS_Close(listenFd, TRUE);
 }
-
 /*
  *----------------------------------------------------------------------
  *
@@ -556,6 +550,7 @@ static void FCGIUtil_BuildNameValueHeader(
         unsigned char *headerBuffPtr,
         int *headerLenPtr) {
     unsigned char *startHeaderBuffPtr = headerBuffPtr;
+	intptr_t ptrDiff;
 
     ASSERT(nameLen >= 0);
     if (nameLen < 0x80) {
@@ -575,9 +570,10 @@ static void FCGIUtil_BuildNameValueHeader(
         *headerBuffPtr++ = (unsigned char) (valueLen >> 8);
         *headerBuffPtr++ = (unsigned char) valueLen;
     }
-    *headerLenPtr = headerBuffPtr - startHeaderBuffPtr;
+    ptrDiff = headerBuffPtr - startHeaderBuffPtr;
+    ASSERT(0 <= ptrDiff && ptrDiff <= INT_MAX);
+    *headerLenPtr = (int)ptrDiff;
 }
-
 
 #define MAXARGS	16
 static int ParseArgs(int argc, char *argv[],
@@ -639,8 +635,8 @@ static int ParseArgs(int argc, char *argv[],
 				exit(-1);
 			}
 			if((av[ac] = (char *)malloc(strlen(tp1)+1)) == NULL) {
-			    fprintf(stderr, "Cannot allocate %d bytes\n",
-				        (int)strlen(tp1)+1);
+			    fprintf(stderr, "Cannot allocate %llu bytes\n",
+                                    (unsigned long long)strlen(tp1)+1);
 			    exit(-1);
 			}
 			strcpy(av[ac++], tp1);
@@ -659,7 +655,7 @@ static int ParseArgs(int argc, char *argv[],
 	    } else if (!strcmp(argv[i], "-jitcgi")) {
 	        DebugBreak();
 	    } else if (!strcmp(argv[i], "-dbgfcgi")) {
-	        putenv("DEBUG_FCGI=TRUE");
+	        _putenv("DEBUG_FCGI=TRUE");
 #endif
 	    } else if(!strcmp(argv[i], "-start")) {
 		*doBindPtr = FALSE;
@@ -732,18 +728,19 @@ static int ParseArgs(int argc, char *argv[],
     }
     return err;
 }
-
 int main(int argc, char **argv)
 {
     char **envp = environ;
     int count;
     FCGX_Stream *paramsStream;
     unsigned char headerBuff[8];
-    int headerLen, valueLen;
+    int headerLen;
+    intptr_t valueLen;
     char *equalPtr;
     FCGI_BeginRequestRecord beginRecord;
     int	doBind, doStart, nServers;
     char appPath[MAXPATHLEN], bindPath[MAXPATHLEN];
+	intptr_t ptrDiff;
 
     if(ParseArgs(argc, argv, &doBind, &doStart,
 		   (char *) &bindPath, (char *) &appPath, &nServers)) {
@@ -818,14 +815,17 @@ int main(int argc, char **argv)
             exit(1000);
         }
         valueLen = strlen(equalPtr + 1);
+		ASSERT(0 <= valueLen && valueLen <= INT_MAX);
+        ptrDiff = equalPtr - *envp;
+        ASSERT(0 <= ptrDiff && ptrDiff < INT_MAX);
         FCGIUtil_BuildNameValueHeader(
-                equalPtr - *envp,
-                valueLen,
+                (int)ptrDiff,
+				(int)valueLen,
                 &headerBuff[0],
                 &headerLen);
         if(FCGX_PutStr((char *) &headerBuff[0], headerLen, paramsStream) < 0
-                || FCGX_PutStr(*envp, equalPtr - *envp, paramsStream) < 0
-                || FCGX_PutStr(equalPtr + 1, valueLen, paramsStream) < 0) {
+                || FCGX_PutStr(*envp, (int)ptrDiff, paramsStream) < 0
+				|| FCGX_PutStr(equalPtr + 1, (int)valueLen, paramsStream) < 0) {
             exit(FCGX_GetError(paramsStream));
         }
     }
-
-

diff --git a/cgi-fcgi/cgi-fcgi.mak b/cgi-fcgi/cgi-fcgi.mak
index c5b58d15..d9da5a61 100644
--- a/cgi-fcgi/cgi-fcgi.mak
+++ b/cgi-fcgi/cgi-fcgi.mak
@@ -37,14 +37,14 @@ ALL : "$(OUTDIR)\cgi-fcgi.exe"
 
 CLEAN :
 	-@erase "$(INTDIR)\cgi-fcgi.obj"
-	-@erase "$(INTDIR)\vc60.idb"
+	-@erase "$(INTDIR)\vc140.idb"
 	-@erase "$(OUTDIR)\cgi-fcgi.exe"
 
 "$(OUTDIR)" :
     if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
 
 CPP=cl.exe
-CPP_PROJ=/nologo /MD /W3 /Gi /O2 /Ob2 /I "..\include" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Fp"$(INTDIR)\cgifcgi.pch" /YX /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /c 
+CPP_PROJ=/nologo /MD /W3 /EHsc /O2 /Ob2 /I "..\include" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Fp"$(INTDIR)\cgifcgi.pch" /nologo /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /c 
 
 .c{$(INTDIR)}.obj::
    $(CPP) @<<
@@ -84,7 +84,7 @@ BSC32_FLAGS=/nologo /o"$(OUTDIR)\cgifcgi.bsc"
 BSC32_SBRS= \
 	
 LINK32=link.exe
-LINK32_FLAGS=libfcgi.lib /nologo /pdb:none /machine:IX86 /out:"$(OUTDIR)\cgi-fcgi.exe" /libpath:"..\libfcgi\Release" 
+LINK32_FLAGS=libfcgi.lib /nologo /pdb:none  /out:"$(OUTDIR)\cgi-fcgi.exe" /libpath:"..\libfcgi\Release" 
 LINK32_OBJS= \
 	"$(INTDIR)\cgi-fcgi.obj" \
 	"..\libfcgi\Release\libfcgi.lib"
@@ -107,8 +107,8 @@ ALL : "$(OUTDIR)\cgi-fcgi.exe" "$(OUTDIR)\cgifcgi.bsc"
 CLEAN :
 	-@erase "$(INTDIR)\cgi-fcgi.obj"
 	-@erase "$(INTDIR)\cgi-fcgi.sbr"
-	-@erase "$(INTDIR)\vc60.idb"
-	-@erase "$(INTDIR)\vc60.pdb"
+	-@erase "$(INTDIR)\vc140.idb"
+	-@erase "$(INTDIR)\vc140.pdb"
 	-@erase "$(OUTDIR)\cgi-fcgi.exe"
 	-@erase "$(OUTDIR)\cgifcgi.bsc"
 
@@ -116,7 +116,7 @@ CLEAN :
     if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
 
 CPP=cl.exe
-CPP_PROJ=/nologo /MDd /W4 /Gm /Gi /ZI /Od /I "..\include" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /FR"$(INTDIR)\\" /Fp"$(INTDIR)\cgifcgi.pch" /YX /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /GZ /c 
+CPP_PROJ=/nologo /MDd /W4 /Gm /EHsc /ZI /Od /I "..\include" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /FR"$(INTDIR)\\" /Fp"$(INTDIR)\cgifcgi.pch" /nologo /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /GZ /c 
 
 .c{$(INTDIR)}.obj::
    $(CPP) @<<
@@ -162,7 +162,7 @@ BSC32_SBRS= \
 <<
 
 LINK32=link.exe
-LINK32_FLAGS=libfcgi.lib /nologo /profile /debug /machine:IX86 /out:"$(OUTDIR)\cgi-fcgi.exe" /libpath:"..\libfcgi\Debug" 
+LINK32_FLAGS=libfcgi.lib /nologo /profile /debug  /out:"$(OUTDIR)\cgi-fcgi.exe" /libpath:"..\libfcgi\Debug" 
 LINK32_OBJS= \
 	"$(INTDIR)\cgi-fcgi.obj" \
 	"..\libfcgi\Debug\libfcgi.lib"
-
-

diff --git a/examples/echo.c b/examples/echo.c
index 0262473b..50ce1efd 100644
--- a/examples/echo.c
+++ b/examples/echo.c
@@ -25,6 +25,12 @@
 extern char **environ;
 #endif
 
+#ifdef _WIN32
+#define GETPID _getpid
+#else
+#define GETPID getpid
+#endif
+
 #include "fcgi_stdio.h"
 
 
@@ -50,7 +56,7 @@ int main ()
 	    "\r\n"
 	    "<title>FastCGI echo</title>"
 	    "<h1>FastCGI echo</h1>\n"
-            "Request number %d,  Process ID: %d<p>\n", ++count, getpid());
+            "Request number %d,  Process ID: %d<p>\n", ++count, GETPID());
 
         if (contentLength != NULL) {
             len = strtol(contentLength, NULL, 10);
-
-

diff --git a/examples/echo-x.c b/examples/echo-x.c
index 71e0d925..689c03db 100644
--- a/examples/echo-x.c
+++ b/examples/echo-x.c
@@ -25,6 +25,12 @@
 extern char **environ;
 #endif
 
+#ifdef _WIN32
+#define GETPID _getpid
+#else
+#define GETPID getpid
+#endif
+
 #include "fcgiapp.h"
 
 static void PrintEnv(FCGX_Stream *out, char *label, char **envp)
@@ -51,7 +57,7 @@ int main ()
            "\r\n"
            "<title>FastCGI echo (fcgiapp version)</title>"
            "<h1>FastCGI echo (fcgiapp version)</h1>\n"
-           "Request number %d,  Process ID: %d<p>\n", ++count, getpid());
+           "Request number %d,  Process ID: %d<p>\n", ++count, GETPID());
 
         if (contentLength != NULL)
             len = strtol(contentLength, NULL, 10);
-
-

diff --git a/examples/threaded.c b/examples/threaded.c
index b9389776..9b3c7ec1 100644
--- a/examples/threaded.c
+++ b/examples/threaded.c
@@ -20,7 +20,8 @@ static int counts[THREAD_COUNT];
 
 static void *doit(void *a)
 {
-    int rc, i, thread_id = (int)a;
+    int rc, i;
+	intptr_t thread_id = (intptr_t)a;
     pid_t pid = getpid();
     FCGX_Request request;
     char *server_name;
@@ -67,7 +68,7 @@ static void *doit(void *a)
 
 int main(void)
 {
-    int i;
+    intptr_t i;
     pthread_t id[THREAD_COUNT];
 
     FCGX_Init();
-
-

diff --git a/examples/echo-cpp.cpp b/examples/echo-cpp.cpp
index e6fd8f9f..70068987 100644
--- a/examples/echo-cpp.cpp
+++ b/examples/echo-cpp.cpp
@@ -40,6 +40,12 @@ extern char ** environ;
 #include "fcgio.h"
 #include "fcgi_config.h"  // HAVE_IOSTREAM_WITHASSIGN_STREAMBUF
 
+#ifdef _WIN32
+#define GETPID _getpid
+#else
+#define GETPID getpid
+#endif
+
 using namespace std;
 
 // Maximum number of bytes allowed to be read from stdin
@@ -55,10 +61,10 @@ static void penv(const char * const * envp)
     cout << "</PRE>\n";
 }
 
-static long gstdin(FCGX_Request * request, char ** content)
+static uintptr_t gstdin(FCGX_Request * request, char ** content)
 {
     char * clenstr = FCGX_GetParam("CONTENT_LENGTH", request->envp);
-    unsigned long clen = STDIN_MAX;
+    uintptr_t clen = STDIN_MAX;
 
     if (clenstr)
     {
@@ -99,7 +105,7 @@ static long gstdin(FCGX_Request * request, char ** content)
 int main (void)
 {
     int count = 0;
-    long pid = getpid();
+    long pid = GETPID();
 
     streambuf * cin_streambuf  = cin.rdbuf();
     streambuf * cout_streambuf = cout.rdbuf();
@@ -133,7 +139,7 @@ int main (void)
         // many http clients (browsers) don't support it (so
         // the connection deadlocks until a timeout expires!).
         char * content;
-        unsigned long clen = gstdin(&request, &content);
+        uintptr_t clen = gstdin(&request, &content);
 
         cout << "Content-type: text/html\r\n"
                 "\r\n"
-
-

diff --git a/examples/authorizer.mak b/examples/authorizer.mak
index 084b3f8a..40b6ff68 100644
--- a/examples/authorizer.mak
+++ b/examples/authorizer.mak
@@ -37,14 +37,14 @@ ALL : "$(OUTDIR)\authorizer.exe"
 
 CLEAN :
 	-@erase "$(INTDIR)\authorizer.obj"
-	-@erase "$(INTDIR)\vc60.idb"
+	-@erase "$(INTDIR)\vc140.idb"
 	-@erase "$(OUTDIR)\authorizer.exe"
 
 "$(OUTDIR)" :
     if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
 
 CPP=cl.exe
-CPP_PROJ=/nologo /MD /W3 /Gi /O2 /Ob2 /I "..\include" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Fp"$(INTDIR)\authorizer.pch" /YX /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /c 
+CPP_PROJ=/nologo /MD /W3 /EHsc /O2 /Ob2 /I "..\include" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Fp"$(INTDIR)\authorizer.pch" /nologo /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /c 
 
 .c{$(INTDIR)}.obj::
    $(CPP) @<<
@@ -84,7 +84,7 @@ BSC32_FLAGS=/nologo /o"$(OUTDIR)\authorizer.bsc"
 BSC32_SBRS= \
 	
 LINK32=link.exe
-LINK32_FLAGS=libfcgi.lib /nologo /pdb:none /machine:IX86 /out:"$(OUTDIR)\authorizer.exe" /libpath:"..\libfcgi\Release" 
+LINK32_FLAGS=libfcgi.lib /nologo /pdb:none  /out:"$(OUTDIR)\authorizer.exe" /libpath:"..\libfcgi\Release" 
 LINK32_OBJS= \
 	"$(INTDIR)\authorizer.obj" \
 	"..\libfcgi\Release\libfcgi.lib"
@@ -107,8 +107,8 @@ ALL : "$(OUTDIR)\authorizer.exe" "$(OUTDIR)\authorizer.bsc"
 CLEAN :
 	-@erase "$(INTDIR)\authorizer.obj"
 	-@erase "$(INTDIR)\authorizer.sbr"
-	-@erase "$(INTDIR)\vc60.idb"
-	-@erase "$(INTDIR)\vc60.pdb"
+	-@erase "$(INTDIR)\vc140.idb"
+	-@erase "$(INTDIR)\vc140.pdb"
 	-@erase "$(OUTDIR)\authorizer.bsc"
 	-@erase "$(OUTDIR)\authorizer.exe"
 
@@ -116,7 +116,7 @@ CLEAN :
     if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
 
 CPP=cl.exe
-CPP_PROJ=/nologo /MDd /W4 /Gm /Gi /ZI /Od /I "..\include" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /FR"$(INTDIR)\\" /Fp"$(INTDIR)\authorizer.pch" /YX /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /GZ /c 
+CPP_PROJ=/nologo /MDd /W4 /Gm /EHsc /ZI /Od /I "..\include" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /FR"$(INTDIR)\\" /Fp"$(INTDIR)\authorizer.pch" /nologo /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /GZ /c 
 
 .c{$(INTDIR)}.obj::
    $(CPP) @<<
@@ -162,7 +162,7 @@ BSC32_SBRS= \
 <<
 
 LINK32=link.exe
-LINK32_FLAGS=libfcgi.lib /nologo /profile /debug /machine:IX86 /out:"$(OUTDIR)\authorizer.exe" /libpath:"..\libfcgi\Debug" 
+LINK32_FLAGS=libfcgi.lib /nologo /profile /debug  /out:"$(OUTDIR)\authorizer.exe" /libpath:"..\libfcgi\Debug" 
 LINK32_OBJS= \
 	"$(INTDIR)\authorizer.obj" \
 	"..\libfcgi\Debug\libfcgi.lib"
-
-

diff --git a/examples/echo.mak b/examples/echo.mak
index cf3e7e63..d63e3c91 100644
--- a/examples/echo.mak
+++ b/examples/echo.mak
@@ -37,14 +37,14 @@ ALL : "$(OUTDIR)\echo.exe"
 
 CLEAN :
 	-@erase "$(INTDIR)\echo.obj"
-	-@erase "$(INTDIR)\vc60.idb"
+	-@erase "$(INTDIR)\vc140.idb"
 	-@erase "$(OUTDIR)\echo.exe"
 
 "$(OUTDIR)" :
     if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
 
 CPP=cl.exe
-CPP_PROJ=/nologo /MD /W3 /Gi /O2 /Ob2 /I "..\include" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Fp"$(INTDIR)\echo.pch" /YX /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /c 
+CPP_PROJ=/nologo /MD /W3 /EHsc /O2 /Ob2 /I "..\include" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Fp"$(INTDIR)\echo.pch" /nologo /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /c 
 
 .c{$(INTDIR)}.obj::
    $(CPP) @<<
@@ -84,7 +84,7 @@ BSC32_FLAGS=/nologo /o"$(OUTDIR)\echo.bsc"
 BSC32_SBRS= \
 	
 LINK32=link.exe
-LINK32_FLAGS=libfcgi.lib /nologo /pdb:none /machine:IX86 /out:"$(OUTDIR)\echo.exe" /libpath:"..\libfcgi\Release" 
+LINK32_FLAGS=libfcgi.lib /nologo /pdb:none  /out:"$(OUTDIR)\echo.exe" /libpath:"..\libfcgi\Release" 
 LINK32_OBJS= \
 	"$(INTDIR)\echo.obj" \
 	"..\libfcgi\Release\libfcgi.lib"
@@ -107,8 +107,8 @@ ALL : "$(OUTDIR)\echo.exe" "$(OUTDIR)\echo.bsc"
 CLEAN :
 	-@erase "$(INTDIR)\echo.obj"
 	-@erase "$(INTDIR)\echo.sbr"
-	-@erase "$(INTDIR)\vc60.idb"
-	-@erase "$(INTDIR)\vc60.pdb"
+	-@erase "$(INTDIR)\vc140.idb"
+	-@erase "$(INTDIR)\vc140.pdb"
 	-@erase "$(OUTDIR)\echo.bsc"
 	-@erase "$(OUTDIR)\echo.exe"
 	-@erase "$(OUTDIR)\echo.map"
@@ -117,7 +117,7 @@ CLEAN :
     if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
 
 CPP=cl.exe
-CPP_PROJ=/nologo /MDd /W4 /Gm /Gi /ZI /Od /I "..\include" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /FR"$(INTDIR)\\" /Fp"$(INTDIR)\echo.pch" /YX /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /GZ /c 
+CPP_PROJ=/nologo /MDd /W4 /Gm /EHsc /ZI /Od /I "..\include" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /FR"$(INTDIR)\\" /Fp"$(INTDIR)\echo.pch" /nologo /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /GZ /c 
 
 .c{$(INTDIR)}.obj::
    $(CPP) @<<
@@ -163,7 +163,7 @@ BSC32_SBRS= \
 <<
 
 LINK32=link.exe
-LINK32_FLAGS=libfcgi.lib /nologo /profile /map:"$(INTDIR)\echo.map" /debug /machine:IX86 /out:"$(OUTDIR)\echo.exe" /libpath:"..\libfcgi\Debug" 
+LINK32_FLAGS=libfcgi.lib /nologo /profile /map:"$(INTDIR)\echo.map" /debug  /out:"$(OUTDIR)\echo.exe" /libpath:"..\libfcgi\Debug" 
 LINK32_OBJS= \
 	"$(INTDIR)\echo.obj" \
 	"..\libfcgi\Debug\libfcgi.lib"

-
-

diff --git a/examples/echo-cpp.mak b/examples/echo-cpp.mak
index 62910ad9..d20b6520 100644
--- a/examples/echo-cpp.mak
+++ b/examples/echo-cpp.mak
@@ -37,14 +37,14 @@ ALL : "$(OUTDIR)\echo-cpp.exe"
 
 CLEAN :
 	-@erase "$(INTDIR)\echo-cpp.obj"
-	-@erase "$(INTDIR)\vc60.idb"
+	-@erase "$(INTDIR)\vc140.idb"
 	-@erase "$(OUTDIR)\echo-cpp.exe"
 
 "$(OUTDIR)" :
     if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
 
 CPP=cl.exe
-CPP_PROJ=/nologo /MD /W3 /Gi /GX /O2 /Ob2 /I "..\include" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Fp"$(INTDIR)\echo-cpp.pch" /YX /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /c 
+CPP_PROJ=/nologo /MD /W3 /EHsc /O2 /Ob2 /I "..\include" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Fp"$(INTDIR)\echo-cpp.pch" /nologo /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /c 
 
 .c{$(INTDIR)}.obj::
    $(CPP) @<<
@@ -84,7 +84,7 @@ BSC32_FLAGS=/nologo /o"$(OUTDIR)\echo-cpp.bsc"
 BSC32_SBRS= \
 	
 LINK32=link.exe
-LINK32_FLAGS=libfcgi.lib /nologo /pdb:none /machine:IX86 /out:"$(OUTDIR)\echo-cpp.exe" /libpath:"..\libfcgi\Release" 
+LINK32_FLAGS=libfcgi.lib /nologo /pdb:none  /out:"$(OUTDIR)\echo-cpp.exe" /libpath:"..\libfcgi\Release" 
 LINK32_OBJS= \
 	"$(INTDIR)\echo-cpp.obj"
 
@@ -107,8 +107,8 @@ ALL : "$(OUTDIR)\echo-cpp.exe" "$(OUTDIR)\echo-cpp.bsc"
 CLEAN :
 	-@erase "$(INTDIR)\echo-cpp.obj"
 	-@erase "$(INTDIR)\echo-cpp.sbr"
-	-@erase "$(INTDIR)\vc60.idb"
-	-@erase "$(INTDIR)\vc60.pdb"
+	-@erase "$(INTDIR)\vc140.idb"
+	-@erase "$(INTDIR)\vc140.pdb"
 	-@erase "$(OUTDIR)\echo-cpp.bsc"
 	-@erase "$(OUTDIR)\echo-cpp.exe"
 
@@ -116,7 +116,7 @@ CLEAN :
     if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
 
 CPP=cl.exe
-CPP_PROJ=/nologo /MDd /W3 /Gm /Gi /GX /ZI /Od /I "..\include" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /FR"$(INTDIR)\\" /Fp"$(INTDIR)\echo-cpp.pch" /YX /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /GZ /c 
+CPP_PROJ=/nologo /MDd /W3 /Gm /EHsc /ZI /Od /I "..\include" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /FR"$(INTDIR)\\" /Fp"$(INTDIR)\echo-cpp.pch" /nologo /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /GZ /c 
 
 .c{$(INTDIR)}.obj::
    $(CPP) @<<
@@ -162,7 +162,7 @@ BSC32_SBRS= \
 <<
 
 LINK32=link.exe
-LINK32_FLAGS=libfcgi.lib /nologo /profile /debug /machine:IX86 /out:"$(OUTDIR)\echo-cpp.exe" /libpath:"..\libfcgi\Debug" 
+LINK32_FLAGS=libfcgi.lib /nologo /profile /debug  /out:"$(OUTDIR)\echo-cpp.exe" /libpath:"..\libfcgi\Debug" 
 LINK32_OBJS= \
 	"$(INTDIR)\echo-cpp.obj"
 

-
-

diff --git a/examples/echox.mak b/examples/echox.mak
index 37876e2d..7a9f94bc 100644
--- a/examples/echox.mak
+++ b/examples/echox.mak
@@ -37,14 +37,14 @@ ALL : "$(OUTDIR)\echo-x.exe"
 
 CLEAN :
 	-@erase "$(INTDIR)\echo-x.obj"
-	-@erase "$(INTDIR)\vc60.idb"
+	-@erase "$(INTDIR)\vc140.idb"
 	-@erase "$(OUTDIR)\echo-x.exe"
 
 "$(OUTDIR)" :
     if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
 
 CPP=cl.exe
-CPP_PROJ=/nologo /MD /W3 /Gi /O2 /Ob2 /I "..\include" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Fp"$(INTDIR)\echox.pch" /YX /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /c 
+CPP_PROJ=/nologo /MD /W3 /EHsc /O2 /Ob2 /I "..\include" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Fp"$(INTDIR)\echox.pch" /nologo /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /c 
 
 .c{$(INTDIR)}.obj::
    $(CPP) @<<
@@ -84,7 +84,7 @@ BSC32_FLAGS=/nologo /o"$(OUTDIR)\echox.bsc"
 BSC32_SBRS= \
 	
 LINK32=link.exe
-LINK32_FLAGS=libfcgi.lib /nologo /pdb:none /machine:IX86 /out:"$(OUTDIR)\echo-x.exe" /libpath:"..\libfcgi\Release" 
+LINK32_FLAGS=libfcgi.lib /nologo /pdb:none  /out:"$(OUTDIR)\echo-x.exe" /libpath:"..\libfcgi\Release" 
 LINK32_OBJS= \
 	"$(INTDIR)\echo-x.obj" \
 	"..\libfcgi\Release\libfcgi.lib"
@@ -107,8 +107,8 @@ ALL : "$(OUTDIR)\echo-x.exe" "$(OUTDIR)\echox.bsc"
 CLEAN :
 	-@erase "$(INTDIR)\echo-x.obj"
 	-@erase "$(INTDIR)\echo-x.sbr"
-	-@erase "$(INTDIR)\vc60.idb"
-	-@erase "$(INTDIR)\vc60.pdb"
+	-@erase "$(INTDIR)\vc140.idb"
+	-@erase "$(INTDIR)\vc140.pdb"
 	-@erase "$(OUTDIR)\echo-x.exe"
 	-@erase "$(OUTDIR)\echox.bsc"
 
@@ -116,7 +116,7 @@ CLEAN :
     if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
 
 CPP=cl.exe
-CPP_PROJ=/nologo /MDd /W4 /Gm /Gi /ZI /Od /I "..\include" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /FR"$(INTDIR)\\" /Fp"$(INTDIR)\echox.pch" /YX /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /GZ /c 
+CPP_PROJ=/nologo /MDd /W4 /Gm /EHsc /ZI /Od /I "..\include" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /FR"$(INTDIR)\\" /Fp"$(INTDIR)\echox.pch" /nologo /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /GZ /c 
 
 .c{$(INTDIR)}.obj::
    $(CPP) @<<
@@ -162,7 +162,7 @@ BSC32_SBRS= \
 <<
 
 LINK32=link.exe
-LINK32_FLAGS=libfcgi.lib /nologo /profile /debug /machine:IX86 /out:"$(OUTDIR)\echo-x.exe" /libpath:"..\libfcgi\Debug" 
+LINK32_FLAGS=libfcgi.lib /nologo /profile /debug  /out:"$(OUTDIR)\echo-x.exe" /libpath:"..\libfcgi\Debug" 
 LINK32_OBJS= \
 	"$(INTDIR)\echo-x.obj" \
 	"..\libfcgi\Debug\libfcgi.lib"

-
-

diff --git a/examples/size.mak b/examples/size.mak
index 6c11177e..c3ade6a1 100644
--- a/examples/size.mak
+++ b/examples/size.mak
@@ -37,14 +37,14 @@ ALL : "$(OUTDIR)\size.exe"
 
 CLEAN :
 	-@erase "$(INTDIR)\size.obj"
-	-@erase "$(INTDIR)\vc60.idb"
+	-@erase "$(INTDIR)\vc140.idb"
 	-@erase "$(OUTDIR)\size.exe"
 
 "$(OUTDIR)" :
     if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
 
 CPP=cl.exe
-CPP_PROJ=/nologo /MD /W3 /Gi /O2 /Ob2 /I "..\include" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Fp"$(INTDIR)\size.pch" /YX /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /c 
+CPP_PROJ=/nologo /MD /W3 /EHsc /O2 /Ob2 /I "..\include" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Fp"$(INTDIR)\size.pch" /nologo /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /c 
 
 .c{$(INTDIR)}.obj::
    $(CPP) @<<
@@ -84,7 +84,7 @@ BSC32_FLAGS=/nologo /o"$(OUTDIR)\size.bsc"
 BSC32_SBRS= \
 	
 LINK32=link.exe
-LINK32_FLAGS=libfcgi.lib /nologo /pdb:none /machine:IX86 /out:"$(OUTDIR)\size.exe" /libpath:"..\libfcgi\Release" 
+LINK32_FLAGS=libfcgi.lib /nologo /pdb:none  /out:"$(OUTDIR)\size.exe" /libpath:"..\libfcgi\Release" 
 LINK32_OBJS= \
 	"$(INTDIR)\size.obj" \
 	"..\libfcgi\Release\libfcgi.lib"
@@ -107,8 +107,8 @@ ALL : "$(OUTDIR)\size.exe" "$(OUTDIR)\size.bsc"
 CLEAN :
 	-@erase "$(INTDIR)\size.obj"
 	-@erase "$(INTDIR)\size.sbr"
-	-@erase "$(INTDIR)\vc60.idb"
-	-@erase "$(INTDIR)\vc60.pdb"
+	-@erase "$(INTDIR)\vc140.idb"
+	-@erase "$(INTDIR)\vc140.pdb"
 	-@erase "$(OUTDIR)\size.bsc"
 	-@erase "$(OUTDIR)\size.exe"
 
@@ -116,7 +116,7 @@ CLEAN :
     if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
 
 CPP=cl.exe
-CPP_PROJ=/nologo /MDd /W4 /Gm /Gi /ZI /Od /I "..\include" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /FR"$(INTDIR)\\" /Fp"$(INTDIR)\size.pch" /YX /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /GZ /c 
+CPP_PROJ=/nologo /MDd /W4 /Gm /EHsc /ZI /Od /I "..\include" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /FR"$(INTDIR)\\" /Fp"$(INTDIR)\size.pch" /nologo /Fo"$(INTDIR)\\" /Fd"$(INTDIR)\\" /FD /GZ /c 
 
 .c{$(INTDIR)}.obj::
    $(CPP) @<<
@@ -162,7 +162,7 @@ BSC32_SBRS= \
 <<
 
 LINK32=link.exe
-LINK32_FLAGS=libfcgi.lib /nologo /profile /debug /machine:IX86 /out:"$(OUTDIR)\size.exe" /libpath:"..\libfcgi\Debug" 
+LINK32_FLAGS=libfcgi.lib /nologo /profile /debug  /out:"$(OUTDIR)\size.exe" /libpath:"..\libfcgi\Debug" 
 LINK32_OBJS= \
 	"$(INTDIR)\size.obj" \
 	"..\libfcgi\Debug\libfcgi.lib"

-
-